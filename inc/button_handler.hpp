#pragma once

#include <sdbusplus/bus.hpp>
#include <sdbusplus/bus/match.hpp>
#include <sdeventplus/event.hpp>
#include <sdeventplus/utility/timer.hpp>
namespace phosphor
{
namespace button
{

// Power Button states
enum class PowerOpState
{
    buttonNotPressed,
    buttonPressed,
    dpoInitiated,
    dpoFpoSeparation,
    fpoInitiated,
};

/**
 * @class Handler
 *
 * This class acts on the signals generated by the
 * xyz.openbmc_project.Chassis.Buttons code when
 * it detects button presses.
 *
 * There are 3 buttons supported - Power, ID, and Reset.
 * As not all systems may implement each button, this class will
 * check for that button on D-Bus before listening for its signals.
 */
class Handler
{
  public:
    Handler() = delete;
    ~Handler() = default;
    Handler(const Handler&) = delete;
    Handler& operator=(const Handler&) = delete;
    Handler(Handler&&) = delete;
    Handler& operator=(Handler&&) = delete;

    /**
     * @brief Constructor
     *
     * @param[in] bus - sdbusplus connection object
     */
    Handler(sdbusplus::bus::bus& bus);

  private:
    /**
     * @brief The handler for a power button press
     *
     * It will power on the system if it's currently off,
     * else it will soft power it off.
     *
     * @param[in] msg - sdbusplus message from signal
     */
    void powerPressed(sdbusplus::message::message& msg);

    /**
     * @brief The handler for a long power button press
     *
     * If the system is currently powered on, it will
     * perform an immediate power off.
     *
     * @param[in] msg - sdbusplus message from signal
     */
    void longPowerPressed(sdbusplus::message::message& msg);

    /**
     * @brief The handler for an ID button press
     *
     * Toggles the ID LED group
     *
     * @param[in] msg - sdbusplus message from signal
     */
    void idPressed(sdbusplus::message::message& msg);

    /**
     * @brief The handler for a reset button press
     *
     * Reboots the host if it is powered on.
     *
     * @param[in] msg - sdbusplus message from signal
     */
    void resetPressed(sdbusplus::message::message& msg);

    /**
     * @brief Checks if system is powered on
     *
     * @return true if powered on, false else
     */
    bool poweredOn() const;

    /**
     * @brief Checks if BMC is in a Ready state
     *
     * @return true if BMC is in ready state, false else
     */
    bool isBmcReady() const;

    /**
     * @brief Returns the service name for an object
     *
     * @param[in] path - the object path
     * @param[in] interface - the interface name
     *
     * @return std::string - the D-Bus service name if found, else
     *                       an empty string
     */
    std::string getService(const std::string& path,
                           const std::string& interface) const;

    /**
     * @brief sdbusplus connection object
     */
    sdbusplus::bus::bus& bus;

    /**
     * @brief Matches on the power button pressed signal
     */
    std::unique_ptr<sdbusplus::bus::match_t> powerButtonPressed;

    /**
     * @brief Matches on the power button released signal
     */
    std::unique_ptr<sdbusplus::bus::match_t> powerButtonReleased;

    /**
     * @brief Matches on the power button long press released signal
     */
    std::unique_ptr<sdbusplus::bus::match_t> powerButtonLongPressReleased;

    /**
     * @brief Matches on the ID button released signal
     */
    std::unique_ptr<sdbusplus::bus::match_t> idButtonReleased;

    /**
     * @brief Matches on the reset button released signal
     */
    std::unique_ptr<sdbusplus::bus::match_t> resetButtonReleased;

    /**
     * @brief Timer used to monitor host power off intervals
     */
    std::unique_ptr<
        sdeventplus::utility::Timer<sdeventplus::ClockId::Monotonic>>
        powerOpTimer;

    /**
     * @brief Holds a time point representing the current time
     * and timeout.
     */
    decltype(std::chrono::steady_clock::now()) pressedTime;

    /**
     * @brief Get the Press Time object
     *
     * @return pressTime
     */
    auto getPressTime() const;

    /**
     * @brief Power Button Pressed
     *
     * @details This method is called when the power button is pressed to
     * initiate host power ON/OFF process. It sets the power operation states -
     * such as buttonPressed, buttonNotPressed, dpoInitiated, etc., - from
     * current state to the next state.
     *
     * @param msg - the sdbusplus message object
     */
    void powerBtnPressed(sdbusplus::message::message& msg);

    /**
     * @brief Power Button Released
     *
     * @details This method is called when the power button is released. Like as
     * in powerBtnPressed, it changes the power operation states as needed.
     *
     * @param msg - the sdbusplus message object
     */
    void powerBtnReleased(sdbusplus::message::message& msg);

    /**
     * @brief Handler to monitor the timeout interval
     *
     */
    void timerHandler();

    /**
     * @brief Update pressTime
     *
     * @details Updates pressTime to a time point representing the current time
     * and timeout.
     *
     * @param timeout - the timeout value to be added to the current time
     */
    void updatePressedTime(std::chrono::milliseconds timeout);

    /**
     * @brief Enum object to hold power operation state
     */
    PowerOpState powerOpState;

    /**
     * @brief poll interval constant
     */
    static constexpr std::chrono::milliseconds pollInterval{1000};

    /**
     * @brief Default button hold down interval constant
     */
    static constexpr std::chrono::milliseconds defaultHoldDownInterval{4000};

    /**
     * @brief Delayed Power Off interval constant
     */
    static constexpr std::chrono::milliseconds dpoInterval{10000};

    /**
     * @brief Fast/Emergency power off interval constant
     */
    static constexpr std::chrono::milliseconds fpoInterval{10000};
};

} // namespace button
} // namespace phosphor
